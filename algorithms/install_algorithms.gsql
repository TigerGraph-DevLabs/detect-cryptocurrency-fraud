# UDF functions
PUT ExprFunctions from "./ExprFunctions.hpp"
PUT ExprUtil from "./ExprUtil.hpp"

# Define graph
USE GRAPH Ethereum

# Schema change for fastRP
CREATE GLOBAL SCHEMA_CHANGE JOB add_index {
   ALTER VERTEX Account ADD ATTRIBUTE (uid INT);
}
RUN GLOBAL SCHEMA_CHANGE JOB add_index

# FastRP queries
CREATE QUERY tg_fastRP_preprocessing (string index_attr) {
  SumAccum<INT> @@index;
  SetAccum<VERTEX> @@vertices;
  Start = {Any};

  start = SELECT s
          FROM Start:s
          POST-ACCUM
            @@vertices += s;

  FOREACH v in @@vertices DO
    temp = {v};
    temp = SELECT s
           FROM temp:s
           POST-ACCUM
            s.setAttr(index_attr,@@index);
    @@index += 1;
  END;
}

CREATE QUERY tg_fastRP(INT num_edges, INT num_nodes, INT k, INT sampling_constant, INT reduced_dimension, DOUBLE normalization_strength, STRING input_weights, STRING index_attr, BOOL print_accum = TRUE, STRING result_attr =  "", STRING file_path = "") {
  MapAccum<INT,INT> @@degree_diagonal;
  MapAccum<INT, ListAccum<DOUBLE>> @@result;
  ListAccum<ListAccum<INT>> @@edge_list;
  FILE f (file_path);
  Start = {ANY};

  info = SELECT s
         FROM Start:s-(:e)-:t
         ACCUM
            @@edge_list += [s.getAttr(index_attr, "INT"),t.getAttr(index_attr, "INT")]
         POST-ACCUM
            @@degree_diagonal += (s.getAttr(index_attr, "INT") -> s.outdegree());

  @@result = fastRP(@@degree_diagonal, @@edge_list, num_edges, num_nodes, k, sampling_constant, reduced_dimension, normalization_strength, input_weights);
  IF print_accum THEN
    PRINT @@result;
  END;
  IF result_attr != "" THEN
    storeEmbeddings = SELECT s FROM Start:s POST-ACCUM s.fastrp_embedding = @@result.get(s.getAttr(index_attr, "INT"));
  END;
  IF file_path != "" THEN
    f.println(@@result);
  END;
}

# Node2vec queries
CREATE QUERY tg_weighted_random_walk_sub(VERTEX source, INT length, INT num_walks, FLOAT p, FLOAT q, FILE f) { 
    /* This query impletemented random walk in Node2vec paper. Link: https://cs.stanford.edu/~jure/pubs/node2vec-kdd16.pdf
    Input: source vertex, random walk length, walk times for each vertex, output file, set of valid edge types
    Output: random walk sequence
    */

    SetAccum<VERTEX> @@pick;
    ListAccum<FLOAT> @@prob;
    ListAccum<VERTEX> @@candidates;
    ListAccum<VERTEX>@@path;
    FLOAT Prob;
    SumAccum<INT> @d_tx=2;
    SumAccum<FLOAT>@score;

            
    FOREACH i in RANGE[0,num_walks-1] DO
        // add source vertex into path
        @@path += source;
        Start = {source};

        WHILE(Start.size()>=0 ) LIMIT length DO 
            // Calculate transition probability
            Start = SELECT s
                    FROM Start:s-(:e)-:t
                    POST-ACCUM 
                        IF t.@d_tx ==0 THEN
                            t.@score = (1/p) //* e.score
                        ELSE IF t.@d_tx == 1 THEN
                            t.@score = 1 //t.score
                        ELSE
                            t.@score = (1/q) //* e.score
                        END;
                // Reset candidates @d_tx =2, start vertex @d_dx = 0
                // store score and vertex of candidates
            candidates = SELECT t
                FROM Start:s-(:e)-:t
                ACCUM t.@d_tx = 2, s.@d_tx = 0
                POST-ACCUM @@prob +=t.@score, @@candidates +=t;
                    
            IF candidates.size() == 0 THEN
                @@path += source;
                continue;
            END;
            // generate prob value based on weight distribution
            Prob = random_distribution(@@prob);
            //print Prob;
            // pick vertex that generated by random function
            @@path += @@candidates.get(Prob);
            @@pick += @@candidates.get(Prob);

            //print @@pick;
            // select the vertex that connected with @@pick in candidates and set @d_tx=1
            sel = SELECT s
                FROM candidates:s-(:e)-:t
                WHERE t == @@candidates.get(Prob)
                POST-ACCUM s.@d_tx =1;

            // select @@pick as the next start vertex
            Start = @@pick;
                    
            // clear accumulators to start next iteration
            @@pick.clear();
            @@prob.clear();
            @@candidates.clear();
        END;  // WHILE
        print @@path;
        f.println(@@path);
        @@path.clear();
    END; // FOREACH
}

CREATE QUERY tg_weighted_random_walk(INT walk_length = 20, INT num_walks = 4, FLOAT p = 1, FLOAT q = 1, STRING filepath = "/home/tigergraph/path.csv") {
    FILE f (filepath);
    Start = {ANY};
    Start = SELECT s
            FROM Start:s
            POST-ACCUM tg_weighted_random_walk_sub(s, walk_length, num_walks, p, q, f);
}

CREATE QUERY tg_node2vec(string filepath = "/home/tigergraph/path.csv", string output_file = "/home/tigergraph/embedding.csv", int dimension) {
   tg_node2vec_sub(dimension, filepath, output_file);
}


INSTALL QUERY tg_weighted_random_walk_sub,tg_weighted_random_walk,tg_node2vec,tg_fastRP_preprocessing,tg_fastRP
